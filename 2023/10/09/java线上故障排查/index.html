<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/ee/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/ee/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/ee/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/ee/images/logo.svg" color="#222">

<link rel="stylesheet" href="/ee/css/main.css">


<link rel="stylesheet" href="/ee/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"kisslei.github.io","root":"/ee/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="引言  线上排查、性能优化等概念也是面试过程中的“常客”，而对于线上遇到的“疑难杂症”，需要通过理性的思维去分析问题、排查问题、定位问题、解决问题，同时，如果解决掉所遇到的问题或瓶颈后，也可以在能力范围之内尝试最优解以及适当考虑拓展性。  在本章中会先讲明线上排查问题的思路，再接着会对于JVM常用的排查工具进行阐述，最后会对于JVM线上常遇的一些故障问题进行全面剖析。  一、JVM线上环境时常见故">
<meta property="og:type" content="article">
<meta property="og:title" content="java线上故障排查">
<meta property="og:url" content="https://kisslei.github.io/ee/2023/10/09/java%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="引言  线上排查、性能优化等概念也是面试过程中的“常客”，而对于线上遇到的“疑难杂症”，需要通过理性的思维去分析问题、排查问题、定位问题、解决问题，同时，如果解决掉所遇到的问题或瓶颈后，也可以在能力范围之内尝试最优解以及适当考虑拓展性。  在本章中会先讲明线上排查问题的思路，再接着会对于JVM常用的排查工具进行阐述，最后会对于JVM线上常遇的一些故障问题进行全面剖析。  一、JVM线上环境时常见故">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://kisslei.github.io/ee/images/pic3.png">
<meta property="og:image" content="https://kisslei.github.io/ee/images/pic4.png">
<meta property="og:image" content="https://kisslei.github.io/ee/images/pic5.png">
<meta property="article:published_time" content="2023-10-09T09:41:42.000Z">
<meta property="article:modified_time" content="2024-01-12T13:19:32.673Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://kisslei.github.io/ee/images/pic3.png">

<link rel="canonical" href="https://kisslei.github.io/ee/2023/10/09/java%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>java线上故障排查 | Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/ee/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/ee/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/ee/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kisslei.github.io/ee/2023/10/09/java%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/ee/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          java线上故障排查
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-10-09 17:41:42" itemprop="dateCreated datePublished" datetime="2023-10-09T17:41:42+08:00">2023-10-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-12 21:19:32" itemprop="dateModified" datetime="2024-01-12T21:19:32+08:00">2024-01-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>  线上排查、性能优化等概念也是面试过程中的“常客”，而对于线上遇到的“疑难杂症”，需要通过理性的思维去分析问题、排查问题、定位问题、解决问题，同时，如果解决掉所遇到的问题或瓶颈后，也可以在能力范围之内尝试最优解以及适当考虑拓展性。</p>
<blockquote>
<p>在本章中会先讲明线上排查问题的思路，再接着会对于JVM常用的排查工具进行阐述，最后会对于JVM线上常遇的一些故障问题进行全面剖析。</p>
</blockquote>
<h2 id="一、JVM线上环境时常见故障与排查思路分析"><a href="#一、JVM线上环境时常见故障与排查思路分析" class="headerlink" title="一、JVM线上环境时常见故障与排查思路分析"></a>一、JVM线上环境时常见故障与排查思路分析</h2><p>  在开发过程中，如果遇到JVM问题时，通常都有各种各样的<strong>本地可视化工具</strong>支持查看。但开发环境中编写出的程序迟早会被部署在生产环境的服务器上，而线上环境偶尔也容易遇到一些突发状况，比如JVM在线上环境往往会出现以下几个问题：</p>
<ul>
<li><p>①JVM内存泄漏。</p>
</li>
<li><p>②JVM内存溢出。</p>
</li>
<li><p>③业务线程死锁。</p>
</li>
<li><p>④应用程序异常宕机。</p>
</li>
<li><p>⑤线程阻塞&#x2F;响应速度变慢。</p>
</li>
<li><p>⑥CPU利用率飙升或100%。</p>
<p>当程序在线上环境发生故障时，就不比开发环境那样，可以通过可视化工具监控、调试，线上环境往往会“恶劣”很多，那当遇到这类问题时又该如何处理呢？首先在碰到这类故障问题时，得具备良好的排查思路，再建立在理论知识的基础上，通过经验+数据的支持依次分析后加以解决。</p>
</li>
</ul>
<h3 id="1-1、线上排查及其解决问题的思路"><a href="#1-1、线上排查及其解决问题的思路" class="headerlink" title="1.1、线上排查及其解决问题的思路"></a>1.1、线上排查及其解决问题的思路</h3><p>  相对而言，解决故障问题也好，处理性能瓶颈也罢，通常思路大致都是相同的，步骤如下：</p>
<ul>
<li><p>①分析问题：根据理论知识+经验分析问题，判断问题可能出现的位置或可能引起问题的原因，将目标缩小到一定范围。</p>
</li>
<li><p>②排查问题：基于上一步的结果，从引发问题的“可疑性”角度出发，从高到低依次进行排查，进一步排除一些选项，将目标范围进一步缩小。</p>
</li>
<li><p>③定位问题：通过相关的监控数据的辅助，以更“细粒度”的手段，将引发问题的原因定位到精准位置。</p>
</li>
<li><p>④解决问题：判断到问题出现的具体位置以及引发的原因后，采取相关措施对问题加以解决。</p>
</li>
<li><p>⑤尝试最优解（非必须）：将原有的问题解决后，在能力范围内，且环境允许的情况下，应该适当考虑问题的最优解（可以从性能、拓展性、并发等角度出发）。</p>
<p>当然，上述过程是针对特殊问题以及经验老道的开发者而言的，作为“新时代的程序构建者”，那当然得学会合理使用工具来帮助我们快速解决问题：</p>
</li>
<li><p>①摘取或复制问题的关键片段。</p>
</li>
<li><p>②打开<a href="https://link.juejin.cn/?target=https://www.baidu.com/">百度</a>或<a href="https://link.juejin.cn/?target=http://www.google.com/">谷歌</a>后粘贴搜索。</p>
</li>
<li><p>③观察返回结果中，选择标题与描述与自己问题较匹配的资料进入。</p>
</li>
<li><p>④多看几个后，根据其解决方案尝试解决问题。</p>
</li>
<li><p>⑤成功解决后皆大欢喜，尝试无果后“找人&#x2F;问群”。</p>
</li>
<li><p>⑥“外力”无法解决问题时自己动手，根据之前的步骤依次排查解决。</p>
</li>
</ul>
<blockquote>
<p>前面给出了两套解决问题的步骤，面试&#x2F;学习推荐前者，实际开发推荐后者，毕竟面试的时候人家问你怎么解决问题的，你总不能说靠百度。<br> 同时还有关键一点要明白：<strong>“能够搜索出来的资料也是人写出来的，你为何不能成为写的那人呢”</strong>。</p>
</blockquote>
<h3 id="1-2、线上排查的方向"><a href="#1-2、线上排查的方向" class="headerlink" title="1.2、线上排查的方向"></a>1.2、线上排查的方向</h3><p>  通常情况下来说，系统部署在线上出现故障，经过分析排查后，最终诱发问题的根本原因无非在于如下几点：</p>
<ul>
<li><p>应用程序本身导致的问题</p>
<ul>
<li>程序内部频繁触发GC，造成系统出现长时间停顿，导致客户端堆积大量请求。</li>
<li>JVM参数配置不合理，导致线上运行失控，如堆内存、各内存区域太小等。</li>
<li>Java程序代码存在缺陷，导致线上运行出现Bug，如死锁&#x2F;内存泄漏、溢出等。</li>
<li>程序内部资源使用不合理，导致出现问题，如线程&#x2F;DB连接&#x2F;网络连接&#x2F;堆外内存等。</li>
</ul>
</li>
<li><p>上下游内部系统导致的问题</p>
<ul>
<li>上游服务出现并发情况，导致当前程序请求量急剧增加，从而引发问题拖垮系统。</li>
<li>下游服务出现问题，导致当前程序堆积大量请求拖垮系统，如Redis宕机&#x2F;DB阻塞等。</li>
</ul>
</li>
<li><p>程序所部署的机器本身导致的问题</p>
<ul>
<li>服务器机房网络出现问题，导致网络出现阻塞、当前程序假死等故障。</li>
<li>服务器中因其他程序原因、硬件问题、环境因素（如断电）等原因导致系统不可用。</li>
<li>服务器因遭到入侵导致Java程序受到影响，如木马病毒&#x2F;矿机、劫持脚本等。</li>
</ul>
</li>
<li><p>第三方的RPC远程调用导致的问题</p>
<ul>
<li>作为被调用者提供给第三方调用，第三方流量突增，导致当前程序负载过重出现问题。</li>
<li>作为调用者调用第三方，但因第三方出现问题，引发雪崩问题而造成当前程序崩溃。</li>
</ul>
<p>万变不离其宗，虽然上述中没有将所有可能会发生问题的位置写到，但总的来说，发生问题排查时，也就是这几个大的方向，先将发生问题的大体定位，然后再逐步推导出具体问题的位置，从而加以解决。</p>
</li>
</ul>
<h2 id="二、Java提供的程序监控及性能调优工具"><a href="#二、Java提供的程序监控及性能调优工具" class="headerlink" title="二、Java提供的程序监控及性能调优工具"></a>二、Java提供的程序监控及性能调优工具</h2><p>  碰到问题时，首先要做的就是定位问题。而一般定位问题是都会基于数据来进行，比如：<strong>程序运行日志、异常堆栈信息、GC日志记录、线程快照文件、堆内存快照文件等</strong>。同时，数据的收集又离不开监控工具的辅助，所以当JVM在线上运行过程中出现问题后，自然避免不了使用一些JDK自带以及第三方提供的工具，如：<code>jps、jstat、jstack、jmap、jhat、hprof、jinfo、arthas</code>等，接下来我们逐个认识这些工具。</p>
<blockquote>
<p><code>jps、jstat、jstack、jmap、jhat、jinfo</code>等命令都是安装JDK后自带的工具，它们的功能主要是调用<code>%JAVA_HOME%/lib/tools.jar</code>包里面的Java方法来实现的，所以如果你想自己打造一个属于自己的JVM监控系统，那在Java程序内部调用该<code>jar</code>包的方法即可实现。<br> JDK官方提供的<a href="https://link.juejin.cn/?target=https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jps.html">JDK工具参考文档</a>，当然，如果你不会使用这些工具，也可以通过参数：<code>tool -help</code>来查看它的使用方法，如：<code>jps -help</code>。</p>
</blockquote>
<blockquote>
<p>PS：对于JDK提供的这些工具了解的可以直接跳到第三阶段。</p>
</blockquote>
<h3 id="2-1、进程监控工具-jps"><a href="#2-1、进程监控工具-jps" class="headerlink" title="2.1、进程监控工具 - jps"></a>2.1、进程监控工具 - jps</h3><p>  <code>jps</code>工具的主要作用是用来查看机器上运行的Java进程，类似于Linux系统的<code>ps -aux|grep java</code>命令。<code>jps</code>工具也支持查看其他机器的Java进程，命令格式如下：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jps [ options ] [ hostid ]`</span><br><span class="line"> 查看指令的用法：`jps -help</span><br></pre></td></tr></table></figure>
</blockquote>
<p>其中<code>[options]</code>主要有<code>-q、-m、-l、-v、-V</code>几个选项：</p>
<ul>
<li><code>jps -q</code>：查看机器所有运行的Java进程，但只显示进程号（<code>lvmid</code>）。</li>
<li><code>jps -m</code>：~，只显示传递给<code>main</code>方法的参数。</li>
<li><code>jps -l</code>：~，只显示运行程序主类的包名，或者运行程序<code>jar</code>包的完整路径。</li>
<li><code>jps -v</code>：~，单独显示JVM启动时，显式指定的参数。</li>
<li><code>jps -V</code>：~，显示主类名或者jar包名。</li>
</ul>
<p>其中<code>[hostid]</code>是用来连接其他机器查看Java进程的远程ID。</p>
<blockquote>
<p><code>JPS</code>工具实际使用方式：<code>jps [pid]</code>。</p>
</blockquote>
<h3 id="2-2、配置信息查看工具-jinfo"><a href="#2-2、配置信息查看工具-jinfo" class="headerlink" title="2.2、配置信息查看工具 - jinfo"></a>2.2、配置信息查看工具 - jinfo</h3><p>  <code>jinfo</code>工具主要用于实时查看JVM的运行参数，也可以在运行时动态的调整一些参数。命令格式如下：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jinfo [ option1 ] [ option2 ]`</span><br><span class="line"> 查看指令的用法：`jinfo -help / jinfo -h</span><br></pre></td></tr></table></figure>
</blockquote>
<p>其中<code>[option1]</code>可选项如下：</p>
<ul>
<li><code>&lt;no option&gt;</code>：第一个参数不写，默认输出JVM的全部参数和系统属性。</li>
<li><code>-flag &lt;name&gt;</code>：输出与指定名称<code>&lt;name&gt;</code>对应的所有参数，以及参数值。</li>
<li><code>-flag [+|-]&lt;name&gt;</code>：开启或者关闭与指定名称<code>&lt;name&gt;</code>对应的参数。</li>
<li><code>-flag &lt;name&gt;=&lt;value&gt;</code>：设置与指定名称<code>&lt;name&gt;</code>对应参数的值。</li>
<li><code>-flags</code>：输出JVM全部的参数。</li>
<li><code>-sysprops</code>：输出JVM全部的系统属性。</li>
</ul>
<p>其中<code>[option2]</code>可选项如下：</p>
<ul>
<li><p><code>&lt;pid&gt;</code>：对应的JVM进程ID（必需参数），指定一个<code>jinfo</code>要操作的Java进程。</p>
</li>
<li><p><code>executable &lt;core</code>：输出打印堆栈跟踪的核心文件。</p>
</li>
<li><pre><code>[server-id@]&lt;remote server IP or hostname&gt;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  ：远程操作的地址。</span><br><span class="line"></span><br><span class="line">  - `server-id`：远程`debug`服务的进程ID；</span><br><span class="line">  - `remote server IP/hostname`：远程`debug`服务的主机名 或 IP地址；</span><br><span class="line"></span><br><span class="line">&gt; `Jinfo`工具实际使用方式：`jinfo -flags [pid]`。</span><br><span class="line"></span><br><span class="line">&gt; PS：对于每个不同选项的效果就不再演示了，感兴趣的小伙伴可以自行在本地开个Java进程，然后使用上述的选项进行调试观察。</span><br><span class="line"></span><br><span class="line">### 2.3、信息统计监控工具 - jstat</span><br><span class="line"></span><br><span class="line">  `jstat`工全称为“`Java Virtual Machine statistics monitoring tool`”，该工具可以利用JVM内建的指令对Java程序的资源以及性能进行实时的命令行的监控，监控范围包含：堆空间的各数据区、垃圾回收状况以及类的加载与卸载状态。</span><br><span class="line"></span><br><span class="line">&gt; 命令格式：`jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]`</span><br><span class="line"></span><br><span class="line">其中每个参数的释义如下：</span><br><span class="line"></span><br><span class="line">- `[option]`：监控参数选项。</span><br><span class="line">- `-t`：在输出结果中加上`Timestamp`列，显示系统运行的时间。</span><br><span class="line">- `-h`：可以在周期性数据输出的时候，指定间隔多少行数据后输出一次表头。</span><br><span class="line">- `vmid`：`Virtual Machine ID`虚拟ID，也就是指定一个要监控的Java进程ID。</span><br><span class="line">- `interval`：每次执行的间隔时间，默认单位为`ms`。</span><br><span class="line">- `count`：用于指定输出多少条数据，默认情况下会一直输出。</span><br><span class="line"></span><br><span class="line">执行命令`jstat -option`后，可以看到存在很多选项，如下：</span><br><span class="line"></span><br><span class="line">- `-class`：输出类加载`ClassLoad`相关的信息。</span><br><span class="line">- `-compiler`：显示与JIT即时编译相关的信息。</span><br><span class="line">- `-gc`：显示与GC相关的信息。</span><br><span class="line">- `-gccapacity`：显示每个分代空间的容量以及使用情况。</span><br><span class="line">- `-gcmetacapacity`：输出元数据空间相关的信息。</span><br><span class="line">- `-gcnew`：显示新生代空间相关的信息。</span><br><span class="line">- `-gcnewcapacity`：显示新生代空间的容量大小以及使用情况。</span><br><span class="line">- `-gcold`：输出年老代空间的信息。</span><br><span class="line">- `-gcoldcapacity`：输出年老代空间的容量大小以及使用情况。</span><br><span class="line">- `-gcutil`：显示垃圾回收信息。</span><br><span class="line">- `-gccause`：和`-gcutil`功能相同，但是会额外输出最后一次或本次GC的诱因。</span><br><span class="line">- `-printcompilation`：输出JIT即时编译的方法信息。</span><br><span class="line"></span><br><span class="line">所以`jstat`的实际使用方式如下：</span><br><span class="line"></span><br><span class="line">&gt; `jstat -gc -t -h30 9895 1s 300`</span><br><span class="line">&gt;  -gc：监控GC的状态</span><br><span class="line">&gt;  -t：显示系统运行的时间</span><br><span class="line">&gt;  -h30：间隔30行数据，输出一次表头</span><br><span class="line">&gt;  9895：Java进程ID</span><br><span class="line">&gt;  1s：时间间隔</span><br><span class="line">&gt;  300：本次输出的数据行数</span><br><span class="line"></span><br><span class="line">最终执行效果如下：</span><br><span class="line"> ![jstat工具-命令行监控](/images/timestamp.png)</span><br><span class="line"> 统计列各字段含义如下：</span><br><span class="line"></span><br><span class="line">| 字段名称  | 字段释义                                           |</span><br><span class="line">| --------- | -------------------------------------------------- |</span><br><span class="line">| Timestamp | 系统运行的时间                                     |</span><br><span class="line">| S0C       | 第一个`Survivor`区的总容量大小                     |</span><br><span class="line">| S1C       | 第二个`Survivor`区的总容量大小                     |</span><br><span class="line">| S0U       | 第二个`Survivor`区的已使用大小                     |</span><br><span class="line">| S1U       | 第二个`Survivor`区的已使用大小                     |</span><br><span class="line">| EC        | `Eden`区的总容量大小                               |</span><br><span class="line">| EU        | `Eden`区的已使用大小                               |</span><br><span class="line">| OC        | `Old`区的总容量大小                                |</span><br><span class="line">| OU        | `Old`区的已使用大小                                |</span><br><span class="line">| MC        | `Metaspace`区的总容量大小                          |</span><br><span class="line">| MU        | `Metaspace`区的已使用大小                          |</span><br><span class="line">| CCSC      | `CompressedClassSpace`空间的总大小                 |</span><br><span class="line">| CCSU      | `CompressedClassSpace`空间的已用大小               |</span><br><span class="line">| YGC       | 从程序启动到采样时，期间发生的新生代GC次数         |</span><br><span class="line">| YGCT      | 从程序启动到采样时，期间新生代GC总耗时             |</span><br><span class="line">| FGC       | 从程序启动到采样时，期间发生的整堆GC（FullGC）次数 |</span><br><span class="line">| FGCT      | 从程序启动到采样时，期间整堆GC（FullGC）总耗时     |</span><br><span class="line">| GCT       | 从程序启动到采样时，程序发生GC的总耗时             |</span><br><span class="line"></span><br><span class="line">而除此之外，`[options]`指定其他选项时，也会出现不同的统计列字段，如下：</span><br><span class="line"></span><br><span class="line">| 字段名称 | 字段释义                                        |</span><br><span class="line">| -------- | ----------------------------------------------- |</span><br><span class="line">| S0       | 第一个`Survivor`区的使用率（`S0U/S0C`）         |</span><br><span class="line">| S1       | 第二个`Survivor`区的使用率（`S1U/S1C`）         |</span><br><span class="line">| E        | `Eden`区的使用率（`EU/EC`）                     |</span><br><span class="line">| O        | `Old`区的使用率（`OU/OC`）                      |</span><br><span class="line">| M        | `Metaspace`区的使用率（`MU/MC`）                |</span><br><span class="line">| CCS      | `CompressedClassSpace`区的使用率（`CCSU/CCSC`） |</span><br><span class="line">| NGCMN    | 新生代空间初始容量                              |</span><br><span class="line">| NGCMX    | 新生代空间最大容量                              |</span><br><span class="line">| S0CMN    | 第一个`Survivor`区的初始容量                    |</span><br><span class="line">| S0CMX    | 第一个`Survivor`区的最大容量                    |</span><br><span class="line">| S1CMN    | 第二个`Survivor`区的初始容量                    |</span><br><span class="line">| S1CMX    | 第二个`Survivor`区的最大容量                    |</span><br><span class="line">| OGCMN    | 年老代空间初始容量                              |</span><br><span class="line">| OGCMX    | 年老代空间最大容量                              |</span><br><span class="line">| MCMN     | 元数据空间初始容量                              |</span><br><span class="line">| MCMX     | 元数据空间最大容量                              |</span><br><span class="line">| CCSMN    | 类压缩空间初始容量                              |</span><br><span class="line">| CCSMX    | 类压缩空间最大容量                              |</span><br><span class="line">| TT       | 对象晋升的最小年龄阈值                          |</span><br><span class="line">| MTT      | 对象晋升的最大年龄阈值                          |</span><br><span class="line">| DSS      | 期望的`Survivor`区总大小                        |</span><br><span class="line"></span><br><span class="line">&gt; CCS全称为“`CompressedClassSpace`”，主要是指存储类压缩指针的空间，具体可以看[这个](https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fqq_27093465%2Farticle%2Fdetails%2F106760961)。</span><br><span class="line"></span><br><span class="line">除开堆空间和GC相关的统计列信息之外，`jstat`工具还可以类加载与卸载的状态、监控JIT即时编译，执行`jstat -class [pid]`、`jstat -compiler [pid]`指令即可，效果如下：</span><br><span class="line"> ![jstat工具监控类信息、JIT信息](/images/pic2.png)</span><br><span class="line"> 类加载与卸载相关的监控数据统计列字段解读：</span><br><span class="line"></span><br><span class="line">| 字段名称 | 字段释义                 |</span><br><span class="line">| -------- | ------------------------ |</span><br><span class="line">| Loaded   | JVM已经装载的类数量      |</span><br><span class="line">| Bytes    | 已装载的类占用字节数大小 |</span><br><span class="line">| Unloaded | 已经卸载的类数量         |</span><br><span class="line">| Bytes    | 已卸载的类占用字节数大小 |</span><br><span class="line">| Time     | 卸载和装载类共耗时       |</span><br><span class="line"></span><br><span class="line">JIT即时编译相关的监控数据统计列字段解读：</span><br><span class="line"></span><br><span class="line">| 字段名称     | 字段释义                             |</span><br><span class="line">| ------------ | ------------------------------------ |</span><br><span class="line">| Compiled     | 编译任务执行的总次数                 |</span><br><span class="line">| Failed       | 编译任务执行失败的次数               |</span><br><span class="line">| Invalid      | 编译任务执行失效的次数               |</span><br><span class="line">| Bytes        | 已卸载的类占用字节数大小             |</span><br><span class="line">| Time         | 所有编译任务的总耗时                 |</span><br><span class="line">| FailedType   | 最后一个编译失败的任务类型           |</span><br><span class="line">| FailedMethod | 最后一个编译失败的任务所在的类及方法 |</span><br><span class="line"></span><br><span class="line">&gt; 对于`jstat`工具执行不同指令后，每个统计列的含义都已在上述中解释清楚，如若之后在线上环境采用`jstat`工具排查性能瓶颈时，对于不理解的统计列皆可参考如上释义。</span><br><span class="line"></span><br><span class="line">### 2.4、堆内存统计分析工具 - jmap</span><br><span class="line"></span><br><span class="line">  `jmap`是一个多功能的工具，主要是用于查看堆空间的使用情况，通常会配合`jhat`工具一起使用，它可以用于生成Java堆的`Dump`文件。但除此之外，也可以查看`finalize`队列、元数据空间的详细信息，Java堆中对象统计信息，如每个分区的使用率、当前装配的GC收集器等。</span><br><span class="line"></span><br><span class="line">&gt; 命令格式：&gt; `jmap [ option1 ] [ option2 ]`</span><br><span class="line"></span><br><span class="line">其中`[option1]`可选项有：</span><br><span class="line"></span><br><span class="line">- `[no option]`：查看进程的内存映像信息，与`Solaris pmap`类似。</span><br><span class="line">- `-heap`：显示Java堆空间的详细信息。</span><br><span class="line">- `-histo[:live]`：显示Java堆中对象的统计信息。</span><br><span class="line">- `-clstats`：显示类加载相关的信息。</span><br><span class="line">- `-finalizerinfo`：显示`F-Queue`队列中等待`Finalizer`线程执行`finalizer`方法的对象。</span><br><span class="line">- `-dump:&lt;dump-options&gt;`：生成堆转储快照。</span><br><span class="line">- `-F`：当正常情况下`-dump`和`-histo`执行失效时，前面加`-F`可以强制执行。</span><br><span class="line">- `-help`：显示帮助信息。</span><br><span class="line">- `-J&lt;flag&gt;`：指定传递给运行`jmap`的JVM参数。</span><br><span class="line"></span><br><span class="line">其中`[option2]`与`jinfo`工具的相差无几，可选项如下：</span><br><span class="line"></span><br><span class="line">- `&lt;pid&gt;`：对应的JVM进程ID（必需参数），指定一个`jinfo`要操作的Java进程。</span><br><span class="line"></span><br><span class="line">- `executable &lt;core`：输出打印堆栈跟踪的核心文件。</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  [server-id@]&lt;remote server IP or hostname&gt;：远程操作的地址。</span><br></pre></td></tr></table></figure>

- `server-id`：远程`debug`服务的进程ID；
- `remote server IP/hostname`：远程`debug`服务的主机名 或 IP地址；
</code></pre>
</li>
</ul>
<blockquote>
<p><code>jmap</code>工具实际使用方式：<code>jmap -clstats [pid]</code>或<code>jmap -dump:live,format=b,file=Dump.phrof [pid]</code>等。<br> 堆快照导出命令解析：<br> <code>live</code>：导出堆中存活对象快照；<code>format</code>：指定输出格式；<code>file</code>：指定输出的文件名及其格式（<code>.dat、.phrof</code>等格式）。</p>
</blockquote>
<p>当然，具体的每个选项的效果也不再演示，大家感兴趣可以自行调试后观测。</p>
<blockquote>
<p>不过值得一提的是：大部分JDK提供的工具与JVM通信方式都是通过的<code>Attach</code>机制实现的，该机制可以针对目标JVM进程进行一些操作，比如获取内存<code>Dump</code>、线程<code>Dump</code>、类信息统计、动态加载<code>Agent</code>、动态设置JVM参数、打印JVM参数、获取系统属性等。有兴趣可以去深入研究一下，具体源码位置位于：<code>com.sun.tools.attach</code>包，里面存在一系列<code>Attach</code>机制相关的代码。</p>
</blockquote>
<p>在最后对于<code>histo</code>选项做个简单调试，<code>histo</code>选项主要作用是打印堆空间中对象的统计信息，包括对象实例数、内存空间占用大小等。因为在<code>histo:live</code>前会进行<code>FullGC</code>，所以带上<code>live</code>只会统计存活对象。因此，不加<code>live</code>的堆大小要大于加<code>live</code>堆的大小（因为带<code>live</code>会强制触发一次<code>FullGC</code>），如下：<br> <img src="/ee/images/pic3.png" alt="jmap -histo:live对象统计信息"><br> 上图中，<code>class name</code>是对象的类型，但有些是缩写，对象的缩写类型与真实类型对比如下：</p>
<table>
<thead>
<tr>
<th>缩写类型</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>F</th>
<th>I</th>
<th>J</th>
<th>Z</th>
<th>[</th>
<th>L+类型</th>
</tr>
</thead>
<tbody><tr>
<td>真实类型</td>
<td>byte</td>
<td>char</td>
<td>double</td>
<td>float</td>
<td>int</td>
<td>long</td>
<td>boolean</td>
<td>数组</td>
<td>其他对象</td>
</tr>
</tbody></table>
<h3 id="2-5、堆内存快照分析工具-jhat"><a href="#2-5、堆内存快照分析工具-jhat" class="headerlink" title="2.5、堆内存快照分析工具 - jhat"></a>2.5、堆内存快照分析工具 - jhat</h3><p>  <code>jhat</code>工具一般配合<code>jmap</code>工具使用，主要用于分析<code>jmap</code>工具导出的<code>Dump</code>文件，其中也内嵌了一个微型的<code>HTTP/HTML</code>服务器，所以当<code>jhat</code>工具分析完<code>Dump</code>文件后，可以支持在浏览器中查看分析结果。<br> 不过在线上环境中一般不会直接使用<code>jhat</code>工具对<code>Dump</code>文件进行解析，因为<code>jhat</code>解析<code>Dump</code>文件，尤其是大体积的<code>Dump</code>时，是一个非常耗时且占用硬件资源的过程。所以为了防止占用服务器过多的资源，通常都会将<code>Dump</code>文件copy到其他机器或本地中分析。</p>
<p>  <em>不过话说回来，到了本地一般也不会使用<code>jhat</code>，因为分析之后生成的结果通过浏览器观察时很难看，一般都会选择MAT（<code>Eclipse Memory Analyzer</code>）、<code>IBM HeapAnalyzer</code>、<code>VisualVM</code>、<code>Jprofile</code>等工具。</em></p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jhat`命令格式：`jhat [-stack &lt;bool&gt;] [-refs &lt;bool&gt;] [-port &lt;port&gt;] [-baseline &lt;file&gt;] [-debug &lt;int&gt;] [-version] [-h|-help] &lt;file&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>jhat</code>的这条指令有点长，其中可以选择填写很多参数，释义如下：</p>
<ul>
<li><code>-stack</code>：默认为<code>true</code>，是否开启对象分配调用栈跟踪。</li>
<li><code>-refs</code>：默认为<code>true</code>，是否开启对象引用跟踪</li>
<li><code>-port</code>：默认为<code>7000</code>，设置<code>jhat</code>工具浏览器访问的端口号。</li>
<li><code>-baseline</code>：指定基准堆转储<code>Dump</code>文件，在两个<code>Dump</code>文件中有相同对象时，会被标记为旧对象，不同的对象会被标记为新对象，主要用于对比分析两个不同的<code>Dump</code>文件。</li>
<li><code>-debug</code>：默认为<code>0</code>，设置debug级别，0表示不输出调试信息，值越大信息越详细。</li>
<li><code>-version</code>：显示版本信息。</li>
<li><code>-help</code>：查看帮助信息。</li>
<li><code>&lt;file&gt;</code>：要分析的<code>Dump</code>文件。</li>
<li><code>-J&lt;flag&gt;</code>：<code>jhat</code>工具实际上也是启动了一个JVM进程来执行的，可以通过<code>-J</code>指令为该JVM传递一些JVM参数，如：<code>-J-Xmx128m</code>这类的。</li>
</ul>
<p><code>jhat</code>实际应用方式：<code>jhat HeapDump.dat</code>，效果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">java复制代码&gt; jmap -dump:live,format=b,file=HeapDump.dat <span class="number">7452</span></span><br><span class="line">Dumping heap to HeapDump.dat ...</span><br><span class="line">Heap dump file created</span><br><span class="line"></span><br><span class="line">&gt; jhat HeapDump.dat</span><br><span class="line">Reading from HeapDump.dat...</span><br><span class="line">Dump file created Wed Mar 09 <span class="number">14</span>:<span class="number">50</span>:<span class="number">06</span> CST <span class="number">2022</span></span><br><span class="line">Snapshot read, resolving...</span><br><span class="line">Resolving <span class="number">7818</span> objects...</span><br><span class="line">Chasing references, expect <span class="number">1</span> dots.</span><br><span class="line">Eliminating duplicate references.</span><br><span class="line">Snapshot resolved.</span><br><span class="line">Started HTTP server on port <span class="number">7000</span></span><br><span class="line">Server is ready.</span><br></pre></td></tr></table></figure>

<p>上述过程中，首先通过<code>jmap</code>工具导出了Java堆的内存<code>dump</code>文件，紧接着使用<code>jhat</code>工具对导出的<code>dump</code>文件进行分析，分析完成后可以打开浏览器，输入<code>http://localhost:7000</code>查看<code>jhat</code>分析后生成的结果，如下：<br> <img src="/ee/images/pic4.png" alt="jhat-浏览器分析结果界面"><br> 其中提供了不少选项，从上至下分别为：</p>
<ul>
<li><p>①按照包路径查看不同类的具体对象实例。</p>
</li>
<li><p>②查看堆中的所有<code>Roots</code>节点的集合。</p>
</li>
<li><p>③查看所有类的对象实例数量（包括了JVM自身的类）。</p>
</li>
<li><p>④查看所有类的对象实例数量（除去了JVM自身的类）。</p>
</li>
<li><p>⑤查看Java堆中实例对象的统计直方图（和<code>jmap</code>的对象统计信息差不多）。</p>
</li>
<li><p>⑥查看JVM的<code>finalizer</code>相关信息。</p>
</li>
<li><p>⑦通过</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jhat</span><br></pre></td></tr></table></figure>

<p>工具提供的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QQL</span><br></pre></td></tr></table></figure>

<p>对象查询语言获取指定对象的实例信息。</p>
<ul>
<li><code>QQL</code>具体的语法可以直接访问<code>http://localhost:7000/oqlhelp</code>查看。</li>
</ul>
</li>
</ul>
<p>其实本质上而言，<code>jhat</code>提供的浏览器界面也不怎么方便我们去排除问题。因此，实际分析堆<code>Dump</code>文件时，通常都会采用一些更为直观方便的工具，如：<code>MAT、Jconsole、IBM HeapAnalyzer、visualVm</code>等。</p>
<h3 id="2-6、堆栈跟踪工具-jstack"><a href="#2-6、堆栈跟踪工具-jstack" class="headerlink" title="2.6、堆栈跟踪工具 - jstack"></a>2.6、堆栈跟踪工具 - jstack</h3><p>  <code>jstack</code>工具主要用于捕捉JVM当前时刻的线程快照，线程快照是JVM中每条线程正在执行的方法堆栈集合。在线上情况时，生成线程快照文件可以用于定位线程出现<strong>长时间停顿</strong>的原因，如<strong>线程死锁、死循环、请求外部资源无响应</strong>等等原因导致的线程停顿。</p>
<p>  当线程出现停顿时，可以通过<code>jstack</code>工具生成线程快照，从快照信息中能查看到Java程序内部每条线程的调用堆栈情况，从调用堆栈信息中就可以清晰明了的看出：发生停顿的线程目前在干什么，在等待什么资源等。<br> 同时，当Java程序崩溃时，如果配置好了参数，生成了<code>core</code>文件，咱们也可以通过<code>jstack</code>工具从<code>core</code>文件中提取Java虚拟机栈相关的信息，从而进一步定位程序崩溃的原因。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack`工具命令格式：`jstack [-F] [option1] [option2]</span><br></pre></td></tr></table></figure>
</blockquote>
<p>其中<code>[option1]</code>可选项为：</p>
<ul>
<li><code>-l</code>：除开显示堆栈信息外，额外输出关于锁相关的附加信息（用于排查死锁问题）。</li>
<li><code>-m</code>：如果线程调用到本地方法栈中的本地方法，也显示<code>C/C++</code>的堆栈信息。</li>
</ul>
<p>其中<code>[option2]</code>可选项如下：</p>
<ul>
<li><p><code>&lt;pid&gt;</code>：对应的JVM进程ID（必需参数），指定一个<code>jinfo</code>要操作的Java进程。</p>
</li>
<li><p><code>executable &lt;core</code>：输出打印堆栈跟踪的核心文件。</p>
</li>
<li><pre><code>[server-id@]&lt;remote server IP or hostname&gt;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  ：远程操作的地址。</span><br><span class="line"></span><br><span class="line">  - `server-id`：远程`debug`服务的进程ID；</span><br><span class="line">  - `remote server IP/hostname`：远程`debug`服务的主机名 或 IP地址；</span><br><span class="line"></span><br><span class="line">&gt; `jstack`工具实际使用方式：`jstack -l [pid]`。</span><br><span class="line"></span><br><span class="line">同时，`jstack`工具的`-F`参数与`jmap`的作用相同，当正常执行失效时，加上`-F`可以强制执行`jstack`指令。</span><br><span class="line"></span><br><span class="line">最后，`jstack`工具导出的`Dump`日志值得留意的状态：</span><br><span class="line"></span><br><span class="line">| 状态                         | 释义                 |</span><br><span class="line">| ---------------------------- | -------------------- |</span><br><span class="line">| Deadlock                     | 线程出现死锁         |</span><br><span class="line">| Runnable                     | 线程正在执行中       |</span><br><span class="line">| Waiting on condition         | 线程等待资源         |</span><br><span class="line">| Waiting on monitor entry     | 线程等待获取监视器锁 |</span><br><span class="line">| Suspended                    | 线程暂停             |</span><br><span class="line">| Object.wait()、TIMED_WAITING | 线程挂起             |</span><br><span class="line">| Blocked                      | 线程阻塞             |</span><br><span class="line">| Parked                       | 线程停止             |</span><br><span class="line"></span><br><span class="line">### 2.7、JVM排查工具小结</span><br><span class="line"></span><br><span class="line">  上述分析的工具都是JDK自带的工具，每个不同的工具都拥有各自的作用，可以在不同维度对JVM运行时的状况进行监控，也能够帮助我们在线上环境时快速去定位排除问题。但除开JDK官方提供的一些工具之外，也有非常多第三方工具用起来非常顺手，如`arthas、jprofilter、perfino、Yourkit、Perf4j、JProbe、MAT、Jconsole、visualVm`等，这些工具往往都比前面分析提到的那些JDK工具更实用且功能更加强大。</span><br><span class="line"></span><br><span class="line">## 三、JVM线上故障问题“大合集”与排查实战</span><br><span class="line"></span><br><span class="line">  程序上线后，线上遇到突发状况无疑是一件令人头疼的事情，但作为一位合格的开发者，不是仅会敲出一手流利的代码就足够了，线上排错这项技能也额外重要。但线上排错的能力强弱更取决于经验的丰富与否，**丰富的实操经验与理论知识储备+理性的排错思路**才是线上排查中最为重要的。</span><br><span class="line"></span><br><span class="line">  接下来会对线上环境中发生最为频繁的故障问题进行全方位剖析及实战，如**JVM内存泄漏、内存溢出、业务线程死锁、应用程序异常宕机、线程阻塞/响应速度变慢、CPU利用率飙升或100%** 等。</span><br><span class="line"></span><br><span class="line">### 3.1、线上排查的“前夕”</span><br><span class="line"></span><br><span class="line">  在排查问题时，诱发问题的原因也有可能来自于上下游系统。因此，当出现问题时，首先得定位出现问题的节点，然后针对该节点进行排错。但无论是哪个节点（Java应用、DB、上下游Java系统等），出现问题的原因无非就几个方向：**代码、CPU、磁盘、内存以及网络问题**，所以遇到线上问题时，合理采用OS与JVM提供的工具（如`df、free、top、jstack、jmap、ps`等），将这些方面依次排查一遍即可。</span><br><span class="line"></span><br><span class="line">&gt; 不过需要额外注意：JVM提供的大部分工具在使用时会影响性能，所以如果你的程序是以单机的模式部署，那最好在排查问题之前做好流量迁移（改DNS、Nginx配置等）。如果你的程序是以集群模式部署，那么可以将其中一台机器隔离出来，用于保留现场，也为了更方便的调试问题。</span><br><span class="line">&gt;  同时，如果线上的机器已经无法提供正常服务，那么在排查问题之前首先要做到的是“及时止损”，可以采用版本回滚、服务降级、重启应用等手段让当前节点恢复正常服务。</span><br><span class="line"></span><br><span class="line">### 3.2、JVM内存溢出（OOM）</span><br><span class="line"></span><br><span class="line">先来理解一下内存溢出：</span><br><span class="line"></span><br><span class="line">&gt; 举例：一个木桶只能装`40L`水，但此时往里面倒入`50L`水，多出来的水会从桶顶溢出。换到程序的内存中，这种情况就被称为内存溢出。</span><br><span class="line"></span><br><span class="line">  内存溢出（OOM）在线上排查中是一个比较常见的问题，同时在Java内存空间中，也会有多块区域会发生OOM问题，如堆空间、元空间、栈空间等，具体可参考前面的[深入理解JVM运行时数据区](https://link.juejin.cn?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2Fcf89ef2689c9)这一章节。通常情况下，线上环境产生内存溢出的原因大致上有三类：</span><br><span class="line"></span><br><span class="line">- ①为JVM分配的内存太小，不足以支撑程序正常执行时的数据增长。</span><br><span class="line">- ②编写的Java程序内部存在问题、有Bug，导致GC回收速率跟不上分配速率。</span><br><span class="line">- ③自己的代码或引入的第三方依赖存在内存溢出问题，导致可用内存不足。</span><br><span class="line"></span><br><span class="line">上述②③问题皆是由于编写的Java程序代码不严谨导致的OOM，由于Java内存中产生了大量垃圾对象，导致新对象没有空闲内存分配，从而产生的溢出。</span><br><span class="line"></span><br><span class="line">&gt; 在排查OOM问题时，核心是：哪里OOM了？为什么OOM了？怎么避免出现的OOM？</span><br><span class="line">&gt;  同时，在排查过程中，应当要建立在数据的分析之上，也就是指`Dump`数据。</span><br><span class="line">&gt;  获取堆`Dump`文件方式有两种：</span><br><span class="line">&gt;  ①启动时设置`-XX:HeapDumpPath`，事先指定OOM出现时，自动导出`Dump`文件。</span><br><span class="line">&gt;  ②重启并在程序运行一段时间后，通过工具导出，如前面的`jmap`或第三方工具。</span><br><span class="line"></span><br><span class="line">#### 3.2.1、Java线上OOM排查实操</span><br><span class="line"></span><br><span class="line">模拟案例如下：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">java复制代码// JVM启动参数：-Xms64M -Xmx64M -XX:+HeapDumpOnOutOfMemoryError </span><br><span class="line">// -XX:HeapDumpPath=/usr/local/java/java_code/java_log/Heap_OOM.hprof</span><br><span class="line">public class OOM &#123;</span><br><span class="line">    // 测试内存溢出的对象类</span><br><span class="line">    public static class OomObject&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        List&lt;OomObject&gt; OOMlist = new ArrayList&lt;&gt;();</span><br><span class="line">        // 死循环：反复往集合中添加对象实例</span><br><span class="line">        for(;;)&#123;</span><br><span class="line">            OOMlist.add(new OomObject());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p>在Linux上，先以后台运行的方式启动上述的Java程序：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shell复制代码root@localhost ~]# java -Xms64M -Xmx64M -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/usr/local/java/java_code/java_log/Heap_OOM.hprof OOM &amp;</span><br><span class="line">[1] 78645</span><br></pre></td></tr></table></figure>

<p>等待一段时间后，可以看到在<code>/usr/local/java/java_code/java_log/</code>目录下，已经自动导出了堆<code>Dump</code>文件，接下来我们只需要把这个<code>Dump</code>文件直接往<code>Eclipse MAT(Memory Analyzer Tool)</code>工具里面一丢，然后它就能自动帮你把OOM的原因分析出来，然后根据它分析的结果改善对应的代码即可。</p>
<blockquote>
<p>其实上述这个案例中，你运行之后过一会儿就会给你输出一句OOM异常信息：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">shell复制代码Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at java.util.Arrays.copyOf(Arrays.java:3210)</span><br><span class="line">	at java.util.Arrays.copyOf(Arrays.java:3181)</span><br><span class="line">	at java.util.ArrayList.grow(ArrayList.java:261)</span><br><span class="line">	at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:235)</span><br><span class="line">	at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:227)</span><br><span class="line">	at java.util.ArrayList.add(ArrayList.java:458)</span><br><span class="line">	at OOM.main(OOM.java:13)</span><br></pre></td></tr></table></figure>

<p>  在最后面都已经明确告诉了你，导致OOM的代码位置，因此这个案例没有太大的参考价值，其实也包括大部分他人的OOM排查过程，相对来说参考价值都并非太大，因为排查OOM问题时只需要自己具备理性的思维，步骤都大概相同的，所以接下来重点阐明排查OOM的思路即可。</p>
<hr>
<p>线上OOM问题排查思路：</p>
<ul>
<li>①首先获取<code>Dump</code>文件，最好是上线部署时配置了，这样可以保留第一现场，但如若未配置对应参数，可以调小堆空间，然后重启程序的时候重新配置参数，争取做到“现场”重现。</li>
<li>②如果无法通过配置参数获得程序OOM自然导出的<code>Dump</code>文件，那则可以等待程序在线上运行一段时间，并协调测试人员对各接口进行压测，而后主动式的通过<code>jmap</code>等工具导出堆的<code>Dump</code>文件（这种方式没有程序自动导出的<code>Dump</code>文件效果好）。</li>
<li>③将<code>Dump</code>文件传输到本地，然后通过相关的<code>Dump</code>分析工具分析，如JDK自带的<code>jvisualvm</code>，或第三方的<code>MAT</code>工具等。</li>
<li>④根据分析结果尝试定位问题，先定位问题发生的区域，如：确定是堆外内存还是堆内空间溢出，如果是堆内，是哪个数据区发生了溢出。确定了溢出的区域之后，再分析导致溢出的原因（后面会列出一下常见的OOM原因）。</li>
<li>⑤根据定位到的区域以及原因，做出对应的解决措施，如：优化代码、优化SQL等。</li>
</ul>
<h4 id="3-2-2、线上内存溢出问题小结"><a href="#3-2-2、线上内存溢出问题小结" class="headerlink" title="3.2.2、线上内存溢出问题小结"></a>3.2.2、线上内存溢出问题小结</h4><p>  Java程序在线上出现问题需要排查时，内存溢出问题绝对是“常客”，但通常情况下，OOM大多是因为代码问题导致的，在程序中容易引发OOM的情况：</p>
<ul>
<li><p>①一次性从外部将体积过于庞大的数据载入内存，如DB读表、读本地报表文件等。</p>
</li>
<li><p>②程序中使用容器(<code>Map/List/Set</code>等)后未及时清理，内存紧张而GC无法回收。</p>
</li>
<li><p>③程序逻辑中存在死循环或大量循环，或单个循环中产生大量重复的对象实例。</p>
</li>
<li><p>④程序中引入的第三方依赖中存在BUG问题，因此导致内存出现故障问题。</p>
</li>
<li><p>⑤程序中存在内存泄露问题，一直在蚕食可用内存，GC无法回收导致内存溢出。</p>
</li>
<li><p>⑥第三方依赖加载大量类库，元空间无法载入所有类元数据，因而诱发OOM。</p>
</li>
<li><p>⑦……..</p>
<p>上述都是程序内代码引发OOM的几种原因，在线上遇到这类情况时，要做的就是定位问题代码，而后修复代码后重新上线即可。同时，除开代码诱发的OOM情况外，有时因为程序分配的内存过小也会引发OOM，这种情况是最好解决的，重新分配更大的内存空间就能解决问题。</p>
</li>
</ul>
<blockquote>
<p>不过Java程序中，堆空间、元空间、栈空间等区域都可能出现OOM问题，其中元空间的溢出大部分原因是由于分配空间不够导致的，当然，也不排除会存在“例外的类库”导致OOM。真正意义上的栈空间OOM在线上几乎很难遇见，所以实际线上环境中，堆空间OOM是最常见的，大部分需要排查OOM问题的时候，几乎都是堆空间发生了溢出。</p>
</blockquote>
<h3 id="3-3、JVM内存泄漏"><a href="#3-3、JVM内存泄漏" class="headerlink" title="3.3、JVM内存泄漏"></a>3.3、JVM内存泄漏</h3><p>先来理解一下内存泄漏：</p>
<blockquote>
<p>举例：一个木桶只能装<code>40L</code>水，但此刻我往里面丢块<code>2KG</code>的金砖，那该水桶在之后的过程中，最多只能装<code>38L</code>的水。此时这种情况换到程序的内存中，就被称为内存泄漏。<br> PS：不考虑物体密度的情况，举例说明不要死磕！</p>
</blockquote>
<p>  内存泄漏和内存溢出两个概念之间，总让人有些混淆，但本质上是两个完全不同的问题。不过在发生内存溢出时，有可能是因为内存泄漏诱发的，但内存泄漏绝对不可能因为OOM引发。</p>
<p>线上的Java程序中，出现内存泄漏主要分为两种情况：</p>
<ul>
<li><p>①堆内泄漏：由于代码不合理导致内存出现泄漏，如垃圾对象与静态对象保持着引用、未正确的关闭外部连接等。</p>
</li>
<li><p>②堆外泄漏：申请<code>buffer</code>流后未释放内存、直接内存中的数据未手动清理等。</p>
<p>而一般在线上排查时并不能直接检测出内存泄漏问题，因为是否存在内存溢出问题除非监控了堆空间的对象变化，否则在正常情况下很难发觉。因此，通常情况下线上遇到泄漏问题时，都是伴随着OOM问题出现的，也就是：</p>
</li>
</ul>
<blockquote>
<p>排查OOM问题时，发现是由于内存泄漏一直在蚕食可用的空闲内存，最终导致新对象分配时没有空闲内存可用于分配，而造成的内存溢出。</p>
</blockquote>
<h4 id="3-3-1、JVM内存泄漏排查小实战"><a href="#3-3-1、JVM内存泄漏排查小实战" class="headerlink" title="3.3.1、JVM内存泄漏排查小实战"></a>3.3.1、JVM内存泄漏排查小实战</h4><p>内存溢出的模拟案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">java复制代码<span class="comment">// JVM启动参数：-Xms64M -Xmx64M -XX:+HeapDumpOnOutOfMemoryError </span></span><br><span class="line"><span class="comment">// -XX:HeapDumpPath=/usr/local/java/java_code/java_log/Heap_MemoryLeak.hprof</span></span><br><span class="line"><span class="comment">// 如果不做限制，想要观测到内存泄漏导致OOM问题需要很长时间。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemoryLeak</span> &#123;</span><br><span class="line">    <span class="comment">// 长生命周期对象，静态类型的root节点</span></span><br><span class="line">    <span class="keyword">static</span> List&lt;Object&gt; ROOT = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 不断创建新的对象，使用后不手动将其从容器中移除</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= <span class="number">999999999</span>;i++) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">            ROOT.add(obj);</span><br><span class="line">            obj = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先启动该程序：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shell复制代码root@localhost ~]# java -Xms64M -Xmx64M -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/usr/local/java/java_code/java_log/Heap_MemoryLeak.hprof OOM &amp;</span><br><span class="line">[1] 78849</span><br></pre></td></tr></table></figure>

<p>等待片刻后，也会出现异常信息如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">shell复制代码Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at java.util.Arrays.copyOf(Arrays.java:3210)</span><br><span class="line">	at java.util.Arrays.copyOf(Arrays.java:3181)</span><br><span class="line">	at java.util.ArrayList.grow(ArrayList.java:261)</span><br><span class="line">	at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:235)</span><br><span class="line">	at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:227)</span><br><span class="line">	at java.util.ArrayList.add(ArrayList.java:458)</span><br><span class="line">	at MemoryLeak.main(MemoryLeak.java:14)</span><br></pre></td></tr></table></figure>

<p>  乍一看，这跟之前分析的OOM问题没啥区别，但却并非如此。在Java程序中，理论上那些创建出来的<code>Object</code>对象在使用完成后，内存不足时，GC线程会将其回收，不过由于这些创建出来的对象在最后与静态的成员<code>ROOT</code>建立起了引用关系，而静态成员在JVM中又被作为<code>GcRoots</code>节点来对待的。<br> 因此，所有创建出来的<code>Object</code>对象在使用完成后，因为与<code>ROOT</code>成员存在引用关系，所以都是可以通过根可达的对象，最终导致GC机制无法回收这些“无效”对象。</p>
<blockquote>
<p><strong>该案例中，从程序的执行结果来看，表象是内存溢出，但实则却是内存泄漏。</strong></p>
</blockquote>
<p>  当然，上述案例只是简单模拟复现内存泄漏这种情况，实际开发过程中可能会更为复杂很多，如：</p>
<blockquote>
<p>一个对象在某次业务逻辑执行过程中，与某个静态成员建立了连接，但该对象使用一次后不会再次使用，但因为没有手动去断开与静态成员的引用，因此导致这个“废弃对象”所占用的内存空间一直不会被GC回收。</p>
</blockquote>
<p>所以，大家在开发编码过程中，应当刻意留意：<strong>当自己创建出的对象需要与静态对象建立连接，但使用一次之后明确清楚该对象不会再被使用，应当手动清空该对象与静态节点的引用，也就是手动置空或移除</strong>。如上述案例中，最后应该要<code>ROOT.remove(obj)</code>才可。</p>
<h4 id="3-3-2、线上内存泄漏问题小结"><a href="#3-3-2、线上内存泄漏问题小结" class="headerlink" title="3.3.2、线上内存泄漏问题小结"></a>3.3.2、线上内存泄漏问题小结</h4><p>  如果线上遇到因内存泄露而造成的OOM问题时，应当首先确认是堆内存泄漏，还是堆外内存泄漏，毕竟堆空间和元空间都有可能存在内存泄漏的隐患，搞清楚内存溢出的位置后再进行排查，处理问题会事半功倍。</p>
<blockquote>
<p>常见的内存泄漏例子：<br> ①外部临时连接对象使用后未合理关闭，如DB连接、Socket连接、文件IO流等。<br> ②程序内新创建的对象与长生命周期对象建立引用使用完成后，未及时清理或断开连接，导致新对象一直存在着引用关系，GC无法回收。如：与静态对象、单例对象关联上了。<br> ③申请堆外的直接内存使用完成后，未手动释放或清理内存，从而导致内存泄漏，如：通过魔法类Unsafe申请本地内存、或使用Buffer缓冲区后未清理等。</p>
</blockquote>
<p>不过在理解内存泄漏时有个误区，大家千万不要被误导，先来看这么个说法：</p>
<blockquote>
<p>“在Java中，多个非根对象之间相互引用，保持着存活状态，从而造成引用循环，导致GC机制无法回收该对象所占用的内存区域，从而造成了内存泄漏。”</p>
</blockquote>
<p>  上述这句话乍一听好像没太大问题，但实则该说法在Java中并不成立。因为Java中GC判断算法采用的是可达性分析算法，对于根不可达的对象都会判定为垃圾对象，会被统一回收。因此，就算在堆中有引用循环的情况出现，也不会引发内存泄漏问题。</p>
<h3 id="3-4、业务线程死锁"><a href="#3-4、业务线程死锁" class="headerlink" title="3.4、业务线程死锁"></a>3.4、业务线程死锁</h3><p>  死锁是指两个或两个以上的线程（或进程）在运行过程中，因为资源竞争而造成相互等待的现象，若无外力作用则不会解除等待状态，它们之间的执行都将无法继续下去。举个栗子：</p>
<blockquote>
<p>某一天竹子和熊猫在森林里捡到一把玩具弓箭，竹子和熊猫都想玩，原本说好一人玩一次的来，但是后面竹子耍赖，想再玩一次，所以就把弓一直拿在自己手上，而本应该轮到熊猫玩的，所以熊猫跑去捡起了竹子前面刚刚射出去的箭，然后跑回来之后便发生了如下状况：<br> 熊猫道：竹子，快把你手里的弓给我，该轮到我玩了…..<br> 竹子说：不，你先把你手里的箭给我，我再玩一次就给你…..<br> 最终导致熊猫等着竹子的弓，竹子等着熊猫的箭，双方都不肯退步，结果陷入僵局场面…….</p>
</blockquote>
<p>这个情况在程序中发生时就被称为死锁状况，如果出现后则必须外力介入，然后破坏掉死锁状态后推进程序继续执行。如上述的案例中，此时就必须第三者介入，把“违反约定”的竹子手中的弓拿过去给熊猫，从而打破“僵局”。</p>
<h4 id="3-4-1、线上死锁排查小实战"><a href="#3-4-1、线上死锁排查小实战" class="headerlink" title="3.4.1、线上死锁排查小实战"></a>3.4.1、线上死锁排查小实战</h4><p>上个简单例子感受一下死锁情景：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">java复制代码<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLock</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态成员属于class，是所有实例对象可共享的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(), o2 = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DeadLock</span><span class="params">(<span class="type">boolean</span> flag)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o1) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程：&quot;</span> + Thread.currentThread()</span><br><span class="line">                        .getName() + <span class="string">&quot;持有o1....&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程：&quot;</span> + Thread.currentThread()</span><br><span class="line">                        .getName() + <span class="string">&quot;等待o2....&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (o2) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o2) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程：&quot;</span> + Thread.currentThread()</span><br><span class="line">                        .getName() + <span class="string">&quot;持有o2....&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程：&quot;</span> + Thread.currentThread()</span><br><span class="line">                        .getName() + <span class="string">&quot;等待o1....&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (o1) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;false&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">DeadLock</span>(<span class="literal">true</span>),<span class="string">&quot;T1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">DeadLock</span>(<span class="literal">false</span>),<span class="string">&quot;T2&quot;</span>);</span><br><span class="line">        <span class="comment">// 因为线程调度是按时间片切换决定的，</span></span><br><span class="line">        <span class="comment">// 所以先执行哪个线程是不确定的，也就代表着：</span></span><br><span class="line">        <span class="comment">//  后面的t1.run()可能在t2.run()之前运行</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上是一个简单的死锁案例，在该代码中：</p>
<ul>
<li>当<code>flag==true</code>时，先获取对象<code>o1</code>的锁，获取成功之后休眠<code>500ms</code>，而发生这个动作的必然是<code>t1</code>，因为在<code>main</code>方法中，我们将<code>t1</code>任务的<code>flag</code>显式的置为了<code>true</code>。</li>
<li>而当<code>t1</code>线程睡眠时，<code>t2</code>线程启动，此时<code>t2</code>任务的<code>flag=false</code>，所以会去获取对象<code>o2</code>的锁资源，然后获取成功之后休眠<code>500ms</code>。</li>
<li>此时<code>t1</code>线程睡眠时间结束，<code>t1</code>线程被唤醒后会继续往下执行，然后需要获取<code>o2</code>对象的锁资源，但此时<code>o2</code>已经被<code>t2</code>持有，此时<code>t1</code>会阻塞等待。</li>
<li>而此刻<code>t2</code>线程也从睡眠中被唤醒会继续往下执行，然后需要获取<code>o1</code>对象的锁资源，但此时<code>o1</code>已经被<code>t1</code>持有，此时<code>t2</code>会阻塞等待。</li>
<li>最终导致线程<code>t1、t2</code>相互等待对象的资源，都需要获取对方持有的资源之后才可继续往下执行，最终导致死锁产生。</li>
</ul>
<p>执行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Linux复制代码D:\&gt; javac -encoding utf-8 DeadLock.java  </span><br><span class="line">D:\&gt; java DeadLock  </span><br><span class="line">线程：T1持有o1....</span><br><span class="line">线程：T2持有o2....</span><br><span class="line">线程：T2等待o1....</span><br><span class="line">线程：T1等待o2....</span><br></pre></td></tr></table></figure>

<p>在上述案例中，实际上<code>T1</code>永远获取不到<code>o1</code>，而<code>T2</code>永远也获取不到<code>o2</code>，所以此时发生了死锁情况。那假设如果在线上我们并不清楚死锁是发生在那处代码呢？其实可以通过多种方式定位问题：</p>
<ul>
<li><p>①通过<code>jps+jstack</code>工具排查。</p>
</li>
<li><p>②通过<code>jconsole</code>工具排查。</p>
</li>
<li><p>③通过<code>jvisualvm</code>工具排查。</p>
<p>当然你也可以通过其他一些第三方工具排查问题，但前面方式都是JDK自带的工具，不过一般Java程序都是部署在<code>Linux</code>系统上，所以对于后面两种可视化工具则不太方便使用。因此，线上环境中，更多采用的是第一种<code>jps+jstack</code>方式排查。</p>
</li>
</ul>
<hr>
<p>接下来我们用<code>jps+jstack</code>的方式排查死锁，此时保持原先的<code>cmd/shell</code>窗口不关闭，再新开一个窗口，输入<code>jps</code>指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">linux复制代码D:\&gt; jps</span><br><span class="line">19552 Jps</span><br><span class="line">2892 DeadLock</span><br></pre></td></tr></table></figure>

<p>jps作用是显示当前系统的Java进程情况及其进程<code>ID</code>，可以从上述结果中看出：<code>ID</code>为<code>2892</code>的进程是刚刚前面产生死锁的Java程序，此时我们可以拿着这个<code>ID</code>再通过<code>jstack</code>工具查看该进程的<code>dump</code>日志，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">linux</span><br><span class="line">复制代码D:\&gt; jstack -l 2892</span><br></pre></td></tr></table></figure>

<p>显示结果如下：<br> <img src="/ee/images/pic5.png" alt="jstack工具查看死锁"></p>
<p>可以从<code>dump</code>日志中明显看出，<code>jstack</code>工具从该进程中检测到了一个死锁问题，是由线程名为<code>T1、T2</code>的线程引起的，而死锁问题的诱发原因可能是<code>DeadLock.java:41、DeadLock.java:25</code>行代码引起的。而到这一步之后其实就已经确定了死锁发生的位置，我们就可以跟进代码继续去排查程序中的问题，优化代码之后就可以确保死锁不再发生。</p>
<blockquote>
<p>PS：偷了个懒，死锁的排查小实战是基于Windows系统，但Linux系统的操作也是同样的步骤。</p>
</blockquote>
<h4 id="3-4-2、死锁问题小结"><a href="#3-4-2、死锁问题小结" class="headerlink" title="3.4.2、死锁问题小结"></a>3.4.2、死锁问题小结</h4><p>  Java程序中的死锁问题通常都是由于代码不规范导致的，所以在排查死锁问题时，需要做的就是定位到引发死锁问题的具体代码，然后加以改进后重新上线即可。</p>
<h3 id="3-5、应用程序异常宕机"><a href="#3-5、应用程序异常宕机" class="headerlink" title="3.5、应用程序异常宕机"></a>3.5、应用程序异常宕机</h3><p>  Java应用被部署上线后，程序宕机情况在线上也不是个稀罕事，但程序宕机的原因可能是由于多方面引起的，如：<strong>机房环境因素、服务器本身硬件问题、系统内其他上下游节点引发的雪崩、Java应用自身导致（频繁GC、OOM、流量打崩等）、服务器中被植入木马或矿机脚本</strong>等情况，都有可能导致程序出现异常宕机问题。<br> 处理这类宕机情况，由于原因的不确定性，这个问题更多的是由开发、运维和网安人员来协同解决的，我们需要做的就是能够保证出现情况时，确保程序可以立即重启且能够及时通知运维人员协助排错。所以这种情况下，你可以采用<code>keepalived</code>来解决该问题。</p>
<h4 id="3-5-1、线上Java应用宕机处理小实战"><a href="#3-5-1、线上Java应用宕机处理小实战" class="headerlink" title="3.5.1、线上Java应用宕机处理小实战"></a>3.5.1、线上Java应用宕机处理小实战</h4><p>  <code>keepalived</code>是个做热备、高可用不错的程序，大家可以自行安装一下，该程序的主要功能：可定期执行脚本、出现故障时给指定邮箱发送信件、主机宕机可以做漂移等，我们主要使用它的警报以及定期执行脚本功能。</p>
<p>安装<code>keepalived</code>完成后，可以使用<code>vi</code>命令编辑一下<code>keeplived.conf</code>文件，然后将其内部的监控脚本配置的模块改为如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">shell复制代码vrrp_script chk_nginx_pid &#123;</span><br><span class="line">    # 运行该脚本，脚本内容:Java程序宕机以后，自动开启服务</span><br><span class="line">    script &quot;/usr/local/src/scripts/check_java_pid.sh&quot; </span><br><span class="line">    interval 4 #检测时间间隔（4秒）</span><br><span class="line">    weight -20 #如果条件成立的话，则权重 -20</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>check_java_pid.sh</code>文件的脚本代码如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">shell复制代码java_count=`ps -C java --no-header | wc -l`</span><br><span class="line">if [ $java_count -eq 0 ];then</span><br><span class="line">    java /usr/local/java_code/HelloWorld</span><br><span class="line">    sleep 1</span><br><span class="line">    </span><br><span class="line">    # 这个是用来做漂移的（不用管）</span><br><span class="line">    if [ `ps -C java --no-header | wc -l` -eq 0 ];then</span><br><span class="line">        /usr/local/src/keepalived/etc/rc.d/init.d/keepalived stop</span><br><span class="line">    fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p><code>HelloWorld.java</code>文件代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java复制代码<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;hello,Java!&quot;</span>);</span><br><span class="line">       <span class="keyword">for</span>(;;)&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述的环境搭建完成后，可以测试效果，先启动一个Java应用<code>HelloWorld</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">shell复制代码# 启动Java应用</span><br><span class="line">[root@localhost ~]# java /usr/local/java_code/HelloWorld</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看Java进程</span></span><br><span class="line">[root@localhost ~]# ps aux | grep java</span><br><span class="line">root  69992  0.1  0.7  153884  7968  ?  SS  16:36  0:21  java</span><br><span class="line">root  73835  0.0 0.0  112728  972  pts/0  S+ 16:37  0:00  grep --color=auto java</span><br></pre></td></tr></table></figure>

<p>然后再开启脚本执行权限并启动<code>keeplived</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">shell复制代码# 开启脚本执行权限（我的是root用户，这步其实可以省略）</span><br><span class="line">[root@localhost ~]# chmod +x /usr/local/src/scripts/check_java_pid.sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入到keepalived安装目录并启动keepalived应用</span></span><br><span class="line">[root@localhost ~]# cd /usr/local/src/keepalived/</span><br><span class="line">[root@localhost keepalived]# keepalived-1.2.22/bin/keepalived etc/keepalived</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看keepalived后台进程</span></span><br><span class="line">[root@localhost keepalived]# ps aux | grep keepalived</span><br><span class="line">root  73908  0.0  0.1  42872  1044 ?  Ss  17:01  0:00 keepalived</span><br><span class="line">root  73909  0.0  0.1  42872  1900 ?  S   17:01  0:00 keepalived</span><br><span class="line">root  73910  0.0  0.1  42872  1272 ?  S   17:01  0:00 keepalived</span><br></pre></td></tr></table></figure>

<p>前面所有程序都跑起来之后，现在手动默认Java应用宕机，也就是使用<code>kill</code>杀掉Java进程，如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">shell复制代码# kill -9 69992：强杀Java进程（69992是前面启动Java应用时的进程ID）</span><br><span class="line">[root@localhost ~]# kill -9 69992</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询Java后台进程（此时已经没有Java进程了，因为刚刚被<span class="built_in">kill</span>了）</span></span><br><span class="line">[root@localhost ~]# ps aux | grep java</span><br><span class="line">root  76621  0.0 0.0  112728  972  pts/0  S+ 17:03  0:00  grep --color=auto java</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">间隔三秒左右再次查询Java后台进程</span></span><br><span class="line">[root@localhost ~]# ps aux | grep java</span><br><span class="line">root  79921  0.1  0.7  153884  7968  ?  SS  17:08  0:21  java</span><br><span class="line">root  80014  0.0 0.0  112728  972  pts/0  S+ 17:08  0:00  grep --color=auto java</span><br></pre></td></tr></table></figure>

<p>此时你可以观测到结果，本来被强杀的Java进程，过了几秒后再次查询，会发现后台的Java应用再次复活了！</p>
<h4 id="3-5-2、线上Java应用宕机小结"><a href="#3-5-2、线上Java应用宕机小结" class="headerlink" title="3.5.2、线上Java应用宕机小结"></a>3.5.2、线上Java应用宕机小结</h4><p>  <code>keepalived</code>是一个比较好用的工具，你还可以配置它的邮件提醒服务，当出现问题或重启时，都可以发送邮件给指定邮箱。但这种重启是治标不治本的手段，如果要彻底解决宕机的问题，还需要从根源点出发，从根本上解决掉导致程序宕机的原因。</p>
<h3 id="3-6、线程阻塞-响应速度变慢"><a href="#3-6、线程阻塞-响应速度变慢" class="headerlink" title="3.6、线程阻塞&#x2F;响应速度变慢"></a>3.6、线程阻塞&#x2F;响应速度变慢</h3><p>  响应速度变慢和线程出现阻塞，这两者之间的关系的密不可分的，Java服务中的线程由于执行过程中遇到突发状况导致阻塞，那么对于客户端而言，直接反馈过去的就是响应的速度变慢，所以线程阻塞时必然会造成客户端响应缓慢甚至无响应，但反过来，线程阻塞却不是造成响应速度变慢唯一原因。<br> 响应速度变慢和Java应用宕机同样，属于“复合型”的问题，<strong>Java应用中线程阻塞、TCP连接爆满、SQL执行时间过长、硬件机器硬盘&#x2F;CPU&#x2F;内存资源紧张、上游系统流量过大、第三方中间件或接口出现异常情况、应用并非处理静态资源或同一时刻加载资源过多等</strong>情况都可能造成响应速度变慢，所以排查这类问题时，也是个靠经验来处理的问题。不过排查无响应或响应速度过慢问题时，也有规律可言：</p>
<ul>
<li><p><strong>①系统整体响应缓慢</strong>：如果程序整体响应过慢，那么则是由于压力过大、下游系统存在异常情况、当前Java应用存在问题、当前机器存在问题（网络&#x2F;硬件&#x2F;所在环境）、当前程序所在系统存在问题等等情况导致的。也就是说，只有当应用系统中某一个层面出现全面瘫痪或故障，才有可能导致程序整体出现响应缓慢的问题。</p>
</li>
<li><p><strong>②单个接口响应缓慢</strong>：如果程序中某个接口或某类接口响应速度过慢，但其他接口响应正常，这点毫无疑问，绝对是因为SQL问题、接口内部实现存在问题等原因导致的，如查询的数量过大、内部调用的第三方接口出现问题、内部代码逻辑不正确导致线程阻塞、线程出现死锁情况等等。</p>
<p>上述两种其实可以理解为点和面的区别，一个是“全面”性质的，而另外一种则是“单点”性质的。除开可以从范围角度区分外，也可以从发生阶段的角度划分，如可分为：<strong>持续性响应缓慢、间接性响应缓慢、偶发性响应缓慢</strong>。</p>
</li>
</ul>
<p> 因为响应缓慢这个问题，诱发的原因有多种，所以在线上遇到这类情况时，理性的分析出问题诱发的原因，再在不同层面根据不同情况加以优化，如：**多线程执行、异步回调通知、引入缓存中间件、MQ削峰填谷、读写分离、静态分离、集群部署、加入搜索引擎…….**，都可被理解成是优化响应速度的方案。</p>
<h3 id="3-7、CPU利用率居高不下或飙升100"><a href="#3-7、CPU利用率居高不下或飙升100" class="headerlink" title="3.7、CPU利用率居高不下或飙升100%"></a>3.7、CPU利用率居高不下或飙升100%</h3><p>  CPU飙升100%和OOM内存溢出是Java面试中老生常谈的话题，CPU100%倒是个比较简单的线上问题，因为毕竟范围已经确定了，CPU100%就只会发生在程序所在的机器上，因此省去了确定问题范围的步骤，所以只需要在单台机器上定位具体的导致CPU飙升的进程，然后再排查问题加以解决即可。</p>
<h4 id="3-7-1、线上CPU100-排查小实战"><a href="#3-7-1、线上CPU100-排查小实战" class="headerlink" title="3.7.1、线上CPU100%排查小实战"></a>3.7.1、线上CPU100%排查小实战</h4><p>模拟的Java案例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">java复制代码<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CpuOverload</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 启动十条休眠线程（模拟不活跃的线程）</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= <span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>*<span class="number">60</span>*<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,<span class="string">&quot;InactivityThread-&quot;</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 启动一条线程不断循环（模拟导致CPU飙升的线程）</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) i++;</span><br><span class="line">        &#125;,<span class="string">&quot;ActiveThread-Hot&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先新建一个<code>shell-SSH</code>窗口，启动该Java应用模拟CPU飙升的情景：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shell复制代码[root@localhost ~]# javac CpuOverload.java</span><br><span class="line">[root@localhost ~]# java CpuOverload</span><br></pre></td></tr></table></figure>

<p>紧接着再在另外一个窗口中，通过<code>top</code>指令查看系统后台的进程状态：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">shell复制代码[root@localhost ~]# top</span><br><span class="line">top - 14:09:20 up 2 days, 16 min,  3 users,  load average: 0.45, 0.15, 0.11</span><br><span class="line">Tasks:  98 total,   1 running,  97 sleeping,   0 stopped,   0 zombie</span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">Cpu(s):100.0 us,  0.0 sy,  0.0 ni,  0.0 <span class="built_in">id</span>,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span></span><br><span class="line">KiB Mem :   997956 total,   286560 free,   126120 used,   585276 buff/cache</span><br><span class="line">KiB Swap:  2097148 total,  2096372 free,      776 used.   626532 avail Mem </span><br><span class="line"></span><br><span class="line">   PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND</span><br><span class="line"> 77915 root      20   0 2249432  25708  11592 S 99.9  2.6   0:28.32 java</span><br><span class="line">   636 root      20   0  298936   6188   4836 S  0.3  0.6   3:39.52 vmtoolsd</span><br><span class="line">     1 root      20   0   46032   5956   3492 S  0.0  0.6   0:04.27 systemd</span><br><span class="line">     2 root      20   0       0      0      0 S  0.0  0.0   0:00.07 kthreadd</span><br><span class="line">     3 root      20   0       0      0      0 S  0.0  0.0   0:04.21 ksoftirqd/0</span><br><span class="line">     5 root       0 -20       0      0      0 S  0.0  0.0   0:00.00 kworker/0:0H</span><br><span class="line">     7 root      rt   0       0      0      0 S  0.0  0.0   0:00.00 migration/0</span><br><span class="line">     8 root      20   0       0      0      0 S  0.0  0.0   0:00.00 rcu_bh</span><br><span class="line">     9 root      20   0       0      0      0 S  0.0  0.0   0:11.97 rcu_sched</span><br><span class="line">     .......</span><br></pre></td></tr></table></figure>

<blockquote>
<p>从如上结果中不难发现，<code>PID</code>为<code>77915</code>的Java进程对CPU的占用率达到<code>99.9%</code>，此时就可以确定，机器的CPU利用率飙升是由于该Java应用引起的。</p>
</blockquote>
<p>此时可以再通过<code>top -Hp [PID]</code>命令查看该Java进程中，CPU占用率最高的线程：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">shell复制代码[root@localhost ~]# top -Hp 77915</span><br><span class="line">.....省略系统资源相关的信息......</span><br><span class="line">   PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND</span><br><span class="line"> 77935 root      20   0 2249432  26496  11560 R 99.9  2.7   3:43.95 java</span><br><span class="line"> 77915 root      20   0 2249432  26496  11560 S  0.0  2.7   0:00.00 java</span><br><span class="line"> 77916 root      20   0 2249432  26496  11560 S  0.0  2.7   0:00.08 java</span><br><span class="line"> 77917 root      20   0 2249432  26496  11560 S  0.0  2.7   0:00.00 java</span><br><span class="line"> 77918 root      20   0 2249432  26496  11560 S  0.0  2.7   0:00.00 java</span><br><span class="line"> 77919 root      20   0 2249432  26496  11560 S  0.0  2.7   0:00.00 java</span><br><span class="line"> 77920 root      20   0 2249432  26496  11560 S  0.0  2.7   0:00.00 java</span><br><span class="line"> 77921 root      20   0 2249432  26496  11560 S  0.0  2.7   0:00.01 java</span><br><span class="line"> .......</span><br></pre></td></tr></table></figure>

<blockquote>
<p>从<code>top -Hp 77915</code>命令的执行结果中可以看出：其他线程均为休眠状态，并未持有CPU资源，而PID为<code>77935</code>的线程对CPU资源的占用率却高达<code>99.9%</code>！</p>
</blockquote>
<p>到此时，导致CPU利用率飙升的“罪魁祸首”已经浮现水面，此时先将该线程的<code>PID</code>转换为<code>16</code>进制的值，方便后续好进一步排查日志信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shell复制代码[root@localhost ~]# printf %x 77935</span><br><span class="line">1306f</span><br></pre></td></tr></table></figure>

<p>到目前为止，咱们已经初步获得了“罪魁祸首”的编号，而后可以再通过前面分析过的<code>jstack</code>工具查看线程的堆栈信息，并通过刚刚拿到的<code>16</code>进制线程ID在其中搜索：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shell复制代码[root@localhost ~]# jstack 77915 | grep 1306f</span><br><span class="line">&quot;ActiveThread-Hot&quot; #18 prio=5 os_prio=0 tid=0x00007f7444107800</span><br><span class="line">            nid=0x1306f runnable [0x00007f7432ade000]</span><br></pre></td></tr></table></figure>

<p>此时，从线程的执行栈信息中，可以明确看出：ID为<code>1306f</code>的线程，线程名为<code>ActiveThread-Hot</code>。同时，你也可以把线程栈信息导出，然后在日志中查看详细信息，如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">shell复制代码[root@localhost ~]# jstack 77915 &gt; java_log/thread_stack.log</span><br><span class="line">[root@localhost ~]# vi java_log/thread_stack.log</span><br><span class="line">-------------然后再按/，输入线程ID：1306f-------------</span><br><span class="line">&quot;ActiveThread-Hot&quot; #18 prio=5 os_prio=0 tid=0x00007f7444107800</span><br><span class="line">            nid=0x1306f runnable [0x00007f7432ade000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">        at CpuOverload.lambda$main$1(CpuOverload.java:18)</span><br><span class="line">        at CpuOverload$$Lambda$2/531885035.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:745)</span><br></pre></td></tr></table></figure>

<p>在线程栈的<code>log</code>日志中，对于线程名称、线程状态、以及该线程的哪行代码消耗的CPU资源最多，都在其中详细列出，接下来要做的就是根据定位到的代码，去Java应用中修正代码重新部署即可。</p>
<blockquote>
<p>当然，如果执行<code>jstack 77915 | grep 1306f</code>命令后，出现的是<code>““VM Thread” os_prio=0 tid=0x00007f871806e000 nid=0xa runnable”</code>这类以<code>“VM Thread”</code>开头的信息，那么则代表这是JVM执行过程中，虚拟机自身的线程造成的，这种情况有需要进一步排查JVM自身的线程了，如GC线程、编译线程等。</p>
</blockquote>
<h4 id="3-7-2、CPU100-排查小结"><a href="#3-7-2、CPU100-排查小结" class="headerlink" title="3.7.2、CPU100%排查小结"></a>3.7.2、CPU100%排查小结</h4><p>CPU100%问题排查步骤几乎是死的模板：</p>
<ul>
<li><p>①<code>top</code>指令查看系统后台进程的资源占用情况，确定是否是Java应用造成的。</p>
</li>
<li><p>②使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -Hp [pid]</span><br></pre></td></tr></table></figure>

<p>进一步排查Java程序中，CPU占用率最高的线程。</p>
<ul>
<li>保存CPU占用率最高的线程<code>PID</code>，并将其转换为16进制的值。</li>
</ul>
</li>
<li><p>③通过<code>jstack</code>工具导出Java应用的堆栈线程快照信息。</p>
</li>
<li><p>④通过前面转换的16进制线程ID，在线程栈信息中搜索，定位导致CPU飙升的具体代码。</p>
</li>
<li><p>⑤确认引发CPU飙升的线程是虚拟机自带的VM线程，还是业务线程。</p>
</li>
<li><p>⑥如果是业务线程就是代码问题，根据栈信息修改为正确的代码后，将程序重新部署上线。</p>
</li>
<li><p>⑦如果是<code>VM</code>线程，那可能是由于频繁GC、频繁编译等JVM的操作导致的，此时需要进一步排查。</p>
</li>
</ul>
<blockquote>
<p>CPU飙升这类问题，一般而言只会有几种原因：<br> ①业务代码中存在问题，如死循环或大量递归等。<br> ②Java应用中创建的线程过多，造成频繁的上下文切换，因而消耗CPU资源。<br> ③虚拟机的线程频繁执行，如频繁GC、频繁编译等。</p>
</blockquote>
<h3 id="3-8、其他线上问题浅谈"><a href="#3-8、其他线上问题浅谈" class="headerlink" title="3.8、其他线上问题浅谈"></a>3.8、其他线上问题浅谈</h3><p>  前面的内容中详细的阐述了线上的多种故障问题及其解决方案，但实则线上也同样还会出现各种各样的“毛病”，如<strong>磁盘使用率100%、DNS劫持、数据库被勒索、木马病毒入侵、矿机脚本植入、网络故障等等</strong>。同时，处理这些问题的手段都需要从经验中去积累，这也是开发者在工作中应当学习的 <strong>“宝贵财富”</strong>。</p>
<h2 id="四、线上排查总结"><a href="#四、线上排查总结" class="headerlink" title="四、线上排查总结"></a>四、线上排查总结</h2><p>  线上排查这项技能更多的是根据经验而谈的，经验越丰富的开发者遇到这类问题时，处理起来会更为得心应手，当线上排查的经验丰富后，就算遇到一些没碰到过的问题，也能排查一二，而不会茫然的束手无策。</p>
<p>  总归而言，线上排查各类问题，没有所谓的千篇一律的方法可教，<strong>丰富的经验+强大的工具+理性的思维</strong>才是处理这类问题的唯一办法，但排查的思路却是不会变化的，步骤也大致相同，也既是开篇所提及到的：</p>
<blockquote>
<p><strong>分析问题、排查问题、定位问题、解决问题、尝试最优解</strong></p>
</blockquote>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/ee/2023/09/27/%E9%99%90%E6%B5%81/" rel="prev" title="限流">
      <i class="fa fa-chevron-left"></i> 限流
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81JVM%E7%BA%BF%E4%B8%8A%E7%8E%AF%E5%A2%83%E6%97%B6%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C%E4%B8%8E%E6%8E%92%E6%9F%A5%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90"><span class="nav-number">2.</span> <span class="nav-text">一、JVM线上环境时常见故障与排查思路分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1%E3%80%81%E7%BA%BF%E4%B8%8A%E6%8E%92%E6%9F%A5%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%B7%AF"><span class="nav-number">2.1.</span> <span class="nav-text">1.1、线上排查及其解决问题的思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2%E3%80%81%E7%BA%BF%E4%B8%8A%E6%8E%92%E6%9F%A5%E7%9A%84%E6%96%B9%E5%90%91"><span class="nav-number">2.2.</span> <span class="nav-text">1.2、线上排查的方向</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81Java%E6%8F%90%E4%BE%9B%E7%9A%84%E7%A8%8B%E5%BA%8F%E7%9B%91%E6%8E%A7%E5%8F%8A%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7"><span class="nav-number">3.</span> <span class="nav-text">二、Java提供的程序监控及性能调优工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1%E3%80%81%E8%BF%9B%E7%A8%8B%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7-jps"><span class="nav-number">3.1.</span> <span class="nav-text">2.1、进程监控工具 - jps</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2%E3%80%81%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF%E6%9F%A5%E7%9C%8B%E5%B7%A5%E5%85%B7-jinfo"><span class="nav-number">3.2.</span> <span class="nav-text">2.2、配置信息查看工具 - jinfo</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5%E3%80%81%E5%A0%86%E5%86%85%E5%AD%98%E5%BF%AB%E7%85%A7%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7-jhat"><span class="nav-number">3.3.</span> <span class="nav-text">2.5、堆内存快照分析工具 - jhat</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6%E3%80%81%E5%A0%86%E6%A0%88%E8%B7%9F%E8%B8%AA%E5%B7%A5%E5%85%B7-jstack"><span class="nav-number">3.4.</span> <span class="nav-text">2.6、堆栈跟踪工具 - jstack</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2%E3%80%81%E7%BA%BF%E4%B8%8A%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E9%97%AE%E9%A2%98%E5%B0%8F%E7%BB%93"><span class="nav-number">3.4.1.</span> <span class="nav-text">3.2.2、线上内存溢出问题小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3%E3%80%81JVM%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="nav-number">3.5.</span> <span class="nav-text">3.3、JVM内存泄漏</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1%E3%80%81JVM%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%8E%92%E6%9F%A5%E5%B0%8F%E5%AE%9E%E6%88%98"><span class="nav-number">3.5.1.</span> <span class="nav-text">3.3.1、JVM内存泄漏排查小实战</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-2%E3%80%81%E7%BA%BF%E4%B8%8A%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98%E5%B0%8F%E7%BB%93"><span class="nav-number">3.5.2.</span> <span class="nav-text">3.3.2、线上内存泄漏问题小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4%E3%80%81%E4%B8%9A%E5%8A%A1%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81"><span class="nav-number">3.6.</span> <span class="nav-text">3.4、业务线程死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-1%E3%80%81%E7%BA%BF%E4%B8%8A%E6%AD%BB%E9%94%81%E6%8E%92%E6%9F%A5%E5%B0%8F%E5%AE%9E%E6%88%98"><span class="nav-number">3.6.1.</span> <span class="nav-text">3.4.1、线上死锁排查小实战</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-2%E3%80%81%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%E5%B0%8F%E7%BB%93"><span class="nav-number">3.6.2.</span> <span class="nav-text">3.4.2、死锁问题小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5%E3%80%81%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%BC%82%E5%B8%B8%E5%AE%95%E6%9C%BA"><span class="nav-number">3.7.</span> <span class="nav-text">3.5、应用程序异常宕机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-1%E3%80%81%E7%BA%BF%E4%B8%8AJava%E5%BA%94%E7%94%A8%E5%AE%95%E6%9C%BA%E5%A4%84%E7%90%86%E5%B0%8F%E5%AE%9E%E6%88%98"><span class="nav-number">3.7.1.</span> <span class="nav-text">3.5.1、线上Java应用宕机处理小实战</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-2%E3%80%81%E7%BA%BF%E4%B8%8AJava%E5%BA%94%E7%94%A8%E5%AE%95%E6%9C%BA%E5%B0%8F%E7%BB%93"><span class="nav-number">3.7.2.</span> <span class="nav-text">3.5.2、线上Java应用宕机小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6%E3%80%81%E7%BA%BF%E7%A8%8B%E9%98%BB%E5%A1%9E-%E5%93%8D%E5%BA%94%E9%80%9F%E5%BA%A6%E5%8F%98%E6%85%A2"><span class="nav-number">3.8.</span> <span class="nav-text">3.6、线程阻塞&#x2F;响应速度变慢</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7%E3%80%81CPU%E5%88%A9%E7%94%A8%E7%8E%87%E5%B1%85%E9%AB%98%E4%B8%8D%E4%B8%8B%E6%88%96%E9%A3%99%E5%8D%87100"><span class="nav-number">3.9.</span> <span class="nav-text">3.7、CPU利用率居高不下或飙升100%</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-7-1%E3%80%81%E7%BA%BF%E4%B8%8ACPU100-%E6%8E%92%E6%9F%A5%E5%B0%8F%E5%AE%9E%E6%88%98"><span class="nav-number">3.9.1.</span> <span class="nav-text">3.7.1、线上CPU100%排查小实战</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-7-2%E3%80%81CPU100-%E6%8E%92%E6%9F%A5%E5%B0%8F%E7%BB%93"><span class="nav-number">3.9.2.</span> <span class="nav-text">3.7.2、CPU100%排查小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-8%E3%80%81%E5%85%B6%E4%BB%96%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98%E6%B5%85%E8%B0%88"><span class="nav-number">3.10.</span> <span class="nav-text">3.8、其他线上问题浅谈</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E7%BA%BF%E4%B8%8A%E6%8E%92%E6%9F%A5%E6%80%BB%E7%BB%93"><span class="nav-number">4.</span> <span class="nav-text">四、线上排查总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/ee/archives/">
        
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/ee/lib/anime.min.js"></script>
  <script src="/ee/lib/velocity/velocity.min.js"></script>
  <script src="/ee/lib/velocity/velocity.ui.min.js"></script>

<script src="/ee/js/utils.js"></script>

<script src="/ee/js/motion.js"></script>


<script src="/ee/js/schemes/muse.js"></script>


<script src="/ee/js/next-boot.js"></script>




  















  

  

</body>
</html>
